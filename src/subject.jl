function temp_schema_prefix()
    prefix = get(ENV, "DATABRICKS_TEMP_SCHEMA_PREFIX", nothing)
    if isnothing(prefix)
        uname =  get(ENV, "USER", get(ENV, "USERNAME", nothing))
        @assert !isnothing(uname)
        prefix = "zz_" * uname
    end
    prefix
end

is_production_schema_prefix() =
    ("zz" == temp_schema_prefix())

function user_schema(case::String)
    @assert length(case) == 8
    return Symbol(temp_schema_prefix() * "_" * case)
end

function user_index_table(case::String)
    @assert length(case) == 8
    sname = user_schema(case)
    return FunSQL.SQLTable(qualifiers = [:ctsi, Symbol(sname)], name = :index,
                           columns = [:person_id, :datetime, :datetime_end])
end

function user_subject_table(case::String)
    @assert length(case) == 8
    if is_production_schema_prefix()
        FunSQL.SQLTable(qualifiers = [:ctsi, :person_map], name = Symbol(case),
                        columns = [:person_id, :subject_id, :added])
    else
        sname = user_schema(case)
        FunSQL.SQLTable(qualifiers = [:ctsi, Symbol(sname)], name = :subject,
                        columns = [:person_id, :subject_id, :added])
    end
end

function funsql_to_subject_id(case)
    name = gensym()
    subject_table = user_subject_table(case)
    @funsql begin
        left_join($name => from($subject_table), $name.person_id == person_id)
        filter(is_null(assert_true(is_not_null($name.person_id))))
        define(person_id => $name.subject_id)
        # TODO: rename person_id to subject_id
    end
end

function user_rebuild_subject_table(db, case)
    @assert length(case) == 8
    create_table_if_not_exists(db, :person_map, Symbol(case),
        :subject_id => "bigint generated by default as identity(START WITH 1)",
        :person_id => :INTEGER,
        :added => :TIMESTAMP)
    catalog = get(ENV, "DATABRICKS_CATALOG", "ctsi")
    person_map_sql = FunSQL.render(db,
        FunSQL.ID(catalog) |> FunSQL.ID(:person_map) |> FunSQL.ID(Symbol(case)))
    subject_sql = FunSQL.render(db,
        FunSQL.ID(catalog) |> FunSQL.ID(user_schema(case)) |> FunSQL.ID(:subject))
    if is_production_schema_prefix()
        query = "CREATE OR REPLACE VIEW $subject_sql AS (SELECT * FROM $person_map_sql)"
        DBInterface.execute(db, query)
        subject_sql = person_map_sql # views are not updatable
    else
        n_start = run(db, "SELECT max(subject_id) AS max FROM $person_map_sql")[1,1] + 100000001
        DBInterface.execute(db, "DROP TABLE IF EXISTS $subject_sql")
        create_table_if_not_exists(db, Symbol(user_schema(case)), :subject,
            :subject_id => "bigint generated by default as identity(START WITH $n_start)",
            :person_id => :INTEGER,
            :added => :TIMESTAMP)
        DBInterface.execute(db, "INSERT INTO $subject_sql SELECT * FROM $person_map_sql")
    end
    index_table = user_index_table(case)
    subject_table = user_subject_table(case)
    additions = FunSQL.render(db, @funsql begin
        from($index_table)
        group(person_id)
        left_join(c => from($subject_table), person_id == c.person_id)
        filter(isnull(c.person_id))
        order(rand())
        select(person_id, now())
    end)
    DBInterface.execute(db, """INSERT INTO $subject_sql (person_id, added) ($additions)""")
    @info "table $subject_sql updated at $(now())"
    return subject_table
end

function user_rebuild_index_table(db, case, query::FunSQL.SQLNode)
    sname = user_schema(case)
    return create_table(db, sname, :index,
               @funsql($query.select(person_id, datetime,
                                     datetime_end => to_timestamp(datetime_end))))
end

function user_rebuild_tables(db, case, query::FunSQL.SQLNode)
    index_table = user_rebuild_index_table(db, case, query)
    subject_table = user_rebuild_subject_table(db, case)
    return (index_table, subject_table)
end

user_tables(case) = (user_index_table(case), user_subject_table(case))
