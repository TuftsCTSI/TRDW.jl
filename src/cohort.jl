function user_schema(case::String)
    @assert length(case) == 8
    prefix = get(ENV, "DATABRICKS_TEMP_SCHEMA_PREFIX", nothing)
    if isnothing(prefix)
        uname =  get(ENV, "USER", get(ENV, "USERNAME", nothing))
        isnothing(uname) && ENV["DATABRICKS_TEMP_SCHEMA_PREFIX"]
        prefix = "zz_" * uname
    end
    return Symbol(prefix * "_" * case)
end

function user_index_table(case)
    sname = user_schema(case)
    return FunSQL.SQLTable(qualifiers = [:ctsi, Symbol(sname)], name = :index,
                         columns = [:person_id, :datetime, :datetime_end])
end

function user_cohort_table(case)
    sname = user_schema(case)
    return FunSQL.SQLTable(qualifiers = [:ctsi, Symbol(sname)], name = :cohort,
                           columns = [:study_id, :person_id, :added, :removed])
end

function funsql_to_study_id(case)
    name = gensym()
    cohort = user_cohort_table(case)
    @funsql begin
        left_join($name => from($cohort).filter(isnotnull(removed)),
                  $name.person_id == person_id)
        filter(is_null(assert_true(is_not_null($name.person_id))))
        define(person_id => $name.study_id)
    end
end

function user_rebuild_cohort_table(db, case)
    catalog = get(ENV, "DATABRICKS_CATALOG", "ctsi")
    schema = user_schema(case)
    index = user_index_table(case)
    cohort = create_table_with_spec(db, schema, :cohort,
            :study_id => "bigint generated by default as identity(START WITH 1 INCREMENT BY 1)",
            :person_id => :INTEGER,
            :added => :TIMESTAMP,
            :removed => :TIMESTAMP)
    name_sql = FunSQL.render(db, FunSQL.ID(catalog) |> FunSQL.ID(schema) |> FunSQL.ID(:cohort))
    deletions = FunSQL.render(db, @funsql begin
        from($cohort)
        filter(isnull(removed))
        left_join(i=>from($index).group(person_id), person_id == i.person_id)
        filter(isnull(i.person_id))
        select(person_id)
    end)
    DBInterface.execute(db,
        """UPDATE $name_sql SET removed = now() WHERE person_id IN ($deletions)""")
    restorations = FunSQL.render(db, @funsql begin
        from($cohort)
        filter(isnotnull(removed))
        join(i=>from($index).group(person_id), person_id == i.person_id)
        select(person_id)
    end)
    DBInterface.execute(db,
        """UPDATE $name_sql SET removed = NULL WHERE person_id IN ($restorations)""")
    additions = FunSQL.render(db, @funsql begin
        from($index)
        group(person_id)
        left_join(c=>from($cohort), person_id == c.person_id)
        filter(isnull(c.person_id))
        order(rand())
        select(person_id, now())
    end)
    DBInterface.execute(db, """INSERT INTO $name_sql (person_id, added) ($additions)""")
    @info "table $name_sql updated at $(now())"
    return cohort
end

function user_rebuild_index_table(db, case, query::FunSQL.SQLNode)
    sname = user_schema(case)
    return create_table(db, sname, :index,
               @funsql($query.select(person_id, datetime,
                                     datetime_end => to_timestamp(datetime_end))))
end

function user_rebuild_tables(db, case, query::FunSQL.SQLNode)
    index = user_rebuild_index_table(db, case, query)
    cohort = user_rebuild_cohort_table(db, case)
    return (index, cohort)
end

user_tables(case) = (user_index_table(case), user_cohort_table(case))
